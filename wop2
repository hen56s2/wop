if getgenv().AutoMenu then
    print("AutoMenu is enabled.")
    
    local args = {
        [1] = {
            [1] = {
                [1] = "\1"
            },
            [2] = "2"
        }
    }
    
    game:GetService("ReplicatedStorage").dataRemoteEvent:FireServer(unpack(args))
    wait(1.5)
    
    local args = {
        [1] = {
            [1] = "ui",
            [2] = "LeaderboardGui"
        }
    }
    
    game:GetService("ReplicatedStorage").Utility.AssetRequester.Remote:InvokeServer(unpack(args))
    
    local args = {
        [1] = "GetWeapons"
    }
    
    game:GetService("ReplicatedStorage").remotes.getData:InvokeServer(unpack(args))
    game:GetService("ReplicatedStorage").remotes.reloadInvy:InvokeServer()
    
    local args = {
        [1] = "Desert Temple"
    }
    
    game:GetService("ReplicatedStorage").remotes.getDungeonStats:InvokeServer(unpack(args))
    
    local args = {
        [1] = {
            [1] = {
                [1] = "\1",
                [2] = {
                    ["\3"] = "select",
                    ["characterIndex"] = 1
                }
            },
            [2] = "L"
        }
    }
    
    game:GetService("ReplicatedStorage").dataRemoteEvent:FireServer(unpack(args))   
    
    wait(0.9)
    
     local success, err = pcall(function()
    
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local Window = Fluent:CreateWindow({
    Title = "Dungeon Quest | NS HUB",
    SubTitle = "Free Version",
    TabWidth = 120,
    Size = UDim2.fromOffset(530, 350),
    Acrylic = true, -- The blur may be detectable, setting this to false disables blur entirely
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl -- Used when theres no MinimizeKeybind
})

--Fluent provides Lucide Icons https://lucide.dev/icons/ for the tabs, icons are optional
local Tabs = {
    Main = Window:AddTab({ Title = "INFO", Icon = "scroll" }),
    Settings = Window:AddTab({ Title = "MACRO", Icon = "settings" })
}

local Options = Fluent.Options

do
    Fluent:Notify({
        Title = "Notification",
        Content = "This is a notification",
        SubContent = "SubContent", -- Optional
        Duration = 5 -- Set to nil to make the notification not disappear
    })

    Tabs.Main:AddParagraph({
        Title = "Script is Working!",
        Content = ""
    })
    
    Tabs.Main:AddParagraph({
        Title = "Supported Devices",
        Content = "- Mobile\n- PC\n- Emulator"
    })
    
    Tabs.Main:AddParagraph({
        Title = "Credits to : Nameless Scripts\nYoutube: Nameless Scripts\nDiscord: https://discord.gg/ZkptAdmFDg",
        Content = ""
    })


    local Tabs = {
        Main = Window:AddTab({ Title = "â•‘ AUTO FARM", Icon = "user-cog" }),
    }

    local ToggleSection = Tabs.Main:AddSection("KILL AURA", {
    })

    local Toggle = Tabs.Main:AddToggle("ToogleFastKillAura", {Title = "Fast Kill Aura [Working!]", Default = false })
    local RunService = game:GetService("RunService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    
    local dataRemoteEvent = ReplicatedStorage:WaitForChild("dataRemoteEvent")
    local fixedSentAt = tick() -- Set once outside the loop
    
    local args = {
        {
            {
                animationLength = 0,
                sentAt = fixedSentAt
            },
            "G"
        }
    }
    
    local connection
    local function checkToggle()
        if connection then
            connection:Disconnect()
            connection = nil
        end
        
        if Toggle.Value then
            connection = RunService.Heartbeat:Connect(function()
                dataRemoteEvent:FireServer(unpack(args))
            end)
        end
    end
    
    Toggle:OnChanged(checkToggle)
    checkToggle()

    local ToggleSection = Tabs.Main:AddSection("Skills", {
    })

    local VirtualInputManager = game:GetService("VirtualInputManager")
local player = game.Players.LocalPlayer

-- Attack Mode Dropdown
local selectedValue = ""

local Dropdown = Tabs.Main:AddDropdown("DropdownSelectAttack", {
    Title = "Select A Dungeon Mode",
    Values = {"Wave Defense", "Normal Dungeons"},
    Multi = false,
    Default = 1,
})

Dropdown:SetValue("Wave Defense")

Dropdown:OnChanged(function(Value)
    selectedValue = Value
end)

-- Skill Mode Dropdown
local skillMode = "No Hold"

local SkillModeDropdown = Tabs.Main:AddDropdown("DropdownSelectSkillMode", {
    Title = "Select Skill Mode",
    Values = {"No Hold", "Hold Skill"},
    Multi = false,
    Default = 1,
})

SkillModeDropdown:SetValue("No Hold")

SkillModeDropdown:OnChanged(function(Value)
    skillMode = Value
end)

-- Multi-select Dropdown for Hold Skills
local selectedSkills = {}

local HoldSkillsDropdown = Tabs.Main:AddDropdown("MultiDropdownSelectHoldSkills", {
    Title = "Select Skills to Hold",
    Values = {"Q", "E"},
    Multi = true,
    Default = {},
})

HoldSkillsDropdown:OnChanged(function(Value)
    selectedSkills = {}
    for skill, state in pairs(Value) do
        if state then
            table.insert(selectedSkills, skill)
        end
    end
end)

-- Toggle for Auto Skill
local isToggleOn = false
local ToggleAttack = Tabs.Main:AddToggle("ToogleAutoSkills", {Title = "Auto Skill Selected", Default = false })

local keySequence = {Enum.KeyCode.Q, Enum.KeyCode.E}  -- Q and E key codes
local keyPressDelay = 0.3 -- Time delay between key presses
local holdDuration = 2 -- Duration to hold the key in seconds

-- Function to simulate key press
local function simulateKeyPress(keyCode)
    local hold = skillMode == "Hold Skill" and table.find(selectedSkills, keyCode.Name)
    VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
    if hold then
        wait(holdDuration)
    else
        wait()
    end
    VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
end

local function findNearestEnemy(path)
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return nil end

    local hrp = character.HumanoidRootPart
    local nearestEnemy = nil
    local minDistance = math.huge

    for _, enemy in pairs(path:GetChildren()) do
        if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") then
            local distance = (enemy.HumanoidRootPart.Position - hrp.Position).Magnitude
            if distance < minDistance and distance <= 50 then
                minDistance = distance
                nearestEnemy = enemy
            end
        end
    end

    return nearestEnemy
end

local function findNearestDungeonEnemy(dungeonPath)
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return nil end

    local hrp = character.HumanoidRootPart
    local nearestEnemy = nil
    local minDistance = math.huge

    for _, subfolder in pairs(dungeonPath:GetChildren()) do
        if subfolder:IsA("Folder") then
            local enemyFolder = subfolder:FindFirstChild("enemyFolder")
            if enemyFolder then
                for _, enemy in pairs(enemyFolder:GetChildren()) do
                    if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") then
                        local distance = (enemy.HumanoidRootPart.Position - hrp.Position).Magnitude
                        if distance < minDistance and distance <= 50 then
                            minDistance = distance
                            nearestEnemy = enemy
                        end
                    end
                end
            end
        end
    end

    return nearestEnemy
end

local function findOdinReincarnation()
    local workspace = game:GetService("Workspace")
    local odin = workspace:FindFirstChild("Odin Reincarnation")

    if odin and odin:IsA("Model") and odin:FindFirstChild("HumanoidRootPart") then
        local character = player.Character
        if character and character:FindFirstChild("HumanoidRootPart") then
            local distance = (odin.HumanoidRootPart.Position - character.HumanoidRootPart.Position).Magnitude
            if distance <= 50 then
                return odin
            end
        end
    end

    return nil
end

local function HandleToggleAction()
    while isToggleOn do
        local nearestEnemy

        if selectedValue == "Wave Defense" then
            nearestEnemy = findNearestEnemy(game.Workspace.enemies)
        elseif selectedValue == "Normal Dungeons" then
            nearestEnemy = findNearestDungeonEnemy(game.Workspace.dungeon)
        end

        -- If no enemy found in the selected mode, search for Odin Reincarnation
        if not nearestEnemy then
            nearestEnemy = findOdinReincarnation()
        end

        if nearestEnemy then
            for _, keyCode in ipairs(keySequence) do
                if not isToggleOn then break end
                simulateKeyPress(keyCode)
                wait(keyPressDelay)
            end
        end
        
        wait(0.1)  -- Small delay to prevent excessive checking
    end
end

ToggleAttack:OnChanged(function(value)
    isToggleOn = value

    if isToggleOn then
        spawn(HandleToggleAction)
    end
end)

if ToggleAttack.Value then
    spawn(HandleToggleAction)
end

local ToggleSection = Tabs.Main:AddSection("Dungeon Set Up", {
})

-- The rest of your toggles remain unchanged
local Toggle = Tabs.Main:AddToggle("ToogleAutoStart", {Title = "Auto Start Dungeon", Default = false })
local function checkToggle()
    while Toggle.Value do
        game:GetService("ReplicatedStorage").remotes.changeStartValue:FireServer()
        wait(5)
    end
end

Toggle:OnChanged(checkToggle)
checkToggle()

local Toggle = Tabs.Main:AddToggle("ToogleAutoRetry", {Title = "Auto Retry", Default = false })
local function checkToggle()
    while Toggle.Value do
        local args = {
            [1] = {
                [1] = {
                    ["\3"] = "vote",
                    ["vote"] = true
                },
                [2] = "."
            }
        }
        
        game:GetService("ReplicatedStorage").dataRemoteEvent:FireServer(unpack(args))
        wait(2)
    end
end

Toggle:OnChanged(checkToggle)
checkToggle()



local Toggle = Tabs.Main:AddToggle("MyToggle", {Title = "Auto Inf Boss", Default = false })
local function checkToggle()
    while Toggle.Value do
        game:GetService("ReplicatedStorage").remotes.changeStartValue:FireServer()
        wait()
    end
end

Toggle:OnChanged(checkToggle)
checkToggle()

local isToggleOn = false
local detached = false
local teleporting = false

-- Initialize player references
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
local humanoid = character:WaitForChild("Humanoid")

-- Initialize TweenService
local TweenService = game:GetService("TweenService")

-- Function to detach the character
local function detachCharacter()
    if not detached then
        detached = true
        humanoidRootPart.Anchored = true
        humanoidRootPart.CanCollide = false
    end
end

-- Function to reattach the character
local function reattachCharacter()
    if detached then
        detached = false
        humanoidRootPart.Anchored = false
        humanoidRootPart.CanCollide = true
    end
end

-- Function to handle the toggle cycle
local function startToggleCycle()
    spawn(function()
        while isToggleOn do
            detachCharacter()
            wait(4)
            if not isToggleOn then break end
            reattachCharacter()
            wait(4)
        end
    end)
end

-- Enemy types and their corresponding settings
local ENEMY_TYPES = {
    ["Tether"] = {
        distance = 2,
        height = 8.5,
        priority = 0,
        tilt = {
            x = -20,
            y = 0,
            z = 0
        }
    },
    ["Adelys"] = {
        distance = 2,
        height = 25,
        priority = 0,
        tilt = {
            x = -20,
            y = 0,
            z = 0
        }
    },
    ["Hela"] = {
        distance = 2,
        height = 8.5,
        priority = 0,
        tilt = {
            x = -20,
            y = 0,
            z = 0
        }
    },
    ["Exalted Queensguard"] = {
        distance = 2,
        height = 5,
        priority = 1,
        tilt = {
            x = -45,
            y = 0,
            z = -10
        }
    },
    ["Eldritch Reaver"] = {
        distance = 5,
        height = -6,
        priority = 3,
        tilt = {
            x = -20,
            y = 0,
            z = 0
        }
    },
    ["Eldritch Prophet"] = {
        distance = 2,
        height = 10,
        priority = 2,
        tilt = {
            x = -45,
            y = 0,
            z = -10
        }
    },
    ["Corrupted Growth"] = {
        distance = 0,
        height = -40,
        priority = 4,
        specialHandling = true
    },
    ["Voidshade"] = {
        distance = 0,
        height = -40,
        priority = 4,
        specialHandling = true
    },
    ["regular"] = {
        distance = 2,
        height = 8.5,
        priority = 4,
        tilt = {
            x = -20,
            y = 0,
            z = 0
        }
    },
    ["Void Familiar"] = {
        distance = 15,
        height = 0,
        priority = 5,
        tilt = {
            x = 0,
            y = 0,
            z = 0
        }
    }
}

-- Modified function to find enemies by priority
local function findEnemy()
    local foundEnemy = nil
    local enemyType = "regular"
    local highestPriority = math.huge
    local myPosition = humanoidRootPart.Position
    local closestDistance = math.huge
    
    -- Check regular enemies
    for _, subfolder in pairs(workspace.dungeon:GetChildren()) do
        if subfolder:IsA("Folder") then
            local enemyFolder = subfolder:FindFirstChild("enemyFolder")
            if enemyFolder then
                for _, enemy in pairs(enemyFolder:GetChildren()) do
                    if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") then
                        local distance = (enemy.HumanoidRootPart.Position - myPosition).magnitude
                        local enemyConfig = ENEMY_TYPES[enemy.Name]
                        
                        if enemyConfig and enemyConfig.priority < highestPriority then
                            foundEnemy = enemy
                            enemyType = enemy.Name
                            highestPriority = enemyConfig.priority
                            closestDistance = distance
                        elseif enemyConfig and enemyConfig.priority == highestPriority and distance < closestDistance then
                            foundEnemy = enemy
                            enemyType = enemy.Name
                            closestDistance = distance
                        elseif not enemyConfig and highestPriority > ENEMY_TYPES["regular"].priority then
                            foundEnemy = enemy
                            enemyType = "regular"
                            highestPriority = ENEMY_TYPES["regular"].priority
                            closestDistance = distance
                        end
                    end
                end
            end
        end
    end
    
    return foundEnemy, enemyType
end

-- Modified floatToTarget function
local function floatToTarget(enemy, enemyType)
    if enemy and not enemy:IsA("Player") then
        local enemyConfig = ENEMY_TYPES[enemyType]
        
        -- Special handling for Corrupted Growth and Voidshade
        if enemyType == "Corrupted Growth" or enemyType == "Voidshade" then
            local offset = Vector3.new(0, -40, 0)
            local downwardRotation = CFrame.Angles(math.rad(78), 0, 0)
            humanoidRootPart.CFrame = CFrame.new(enemy.HumanoidRootPart.Position + offset) * downwardRotation
            return
        end
        
        -- Regular handling for other enemies
        local enemyPos = enemy.HumanoidRootPart.Position
        local lookVector = enemy.HumanoidRootPart.CFrame.LookVector
        
        local targetPosition = enemyPos - (lookVector * enemyConfig.distance)
        targetPosition = Vector3.new(targetPosition.X, enemyPos.Y + enemyConfig.height, targetPosition.Z)
        
        local facing = CFrame.new(targetPosition, enemyPos)
        
        local tilt = CFrame.Angles(
            math.rad(enemyConfig.tilt.x),
            math.rad(enemyConfig.tilt.y),
            math.rad(enemyConfig.tilt.z)
        )
        
        humanoidRootPart.CFrame = facing * tilt
    end
end

local function onHeartbeat()
    if isToggleOn and teleporting then
        local targetEnemy, enemyType = findEnemy()
        if targetEnemy then
            floatToTarget(targetEnemy, enemyType)
        end
    end
end

local Toggle = Tabs.Main:AddToggle("ToogleNewFarm", {
    Title = "Auto Farm Normal Enemies",
    Default = false
})

local heartbeatConnection = nil

Toggle:OnChanged(function(value)
    isToggleOn = value
    teleporting = value
    
    if isToggleOn then
        startToggleCycle()
        
        if heartbeatConnection then
            heartbeatConnection:Disconnect()
        end
        heartbeatConnection = game:GetService("RunService").Heartbeat:Connect(onHeartbeat)
    else
        reattachCharacter()
        
        if heartbeatConnection then
            heartbeatConnection:Disconnect()
        end
    end
end)

player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    humanoid = character:WaitForChild("Humanoid")
    
    if isToggleOn then
        wait(0.1)
        detachCharacter()
    end
end)

            local Toggle = Tabs.Main:AddToggle("ToogleAntiAFK", {Title = "Anti AFK", Default = false })

            local function AntiAFK()
                local Players = game:GetService("Players")
                local VirtualUser = game:GetService("VirtualUser")
            
                local function ResetStatus()
                    print("Status: 123")
                end
            
                Players.LocalPlayer.Idled:Connect(function()
                    VirtualUser:CaptureController()
                    VirtualUser:ClickButton2(Vector2.new())
                    print("Best Scripter Nameless Scripts")
                    wait(2)
                    ResetStatus()
                end)
            end
            
            local function checkToggle()
                if Toggle.Value then
                    AntiAFK()
                end
            end
            
            Toggle:OnChanged(checkToggle)
            checkToggle()        



    local Input = Tabs.Main:AddInput("Input", {
        Title = "Input",
        Default = "Default",
        Placeholder = "Placeholder",
        Numeric = false, -- Only allows numbers
        Finished = false, -- Only calls callback when you press enter
        Callback = function(Value)
            print("Input changed:", Value)
        end
    })

    Input:OnChanged(function()
        print("Input updated:", Input.Value)
    end)
end


-- Addons:
-- SaveManager (Allows you to have a configuration system)
-- InterfaceManager (Allows you to have a interface managment system)

-- Hand the library over to our managers
SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)

-- Ignore keys that are used by ThemeManager.
-- (we dont want configs to save themes, do we?)
SaveManager:IgnoreThemeSettings()

-- You can add indexes of elements the save manager should ignore
SaveManager:SetIgnoreIndexes({})

-- use case for doing it this way:
-- a script hub could have themes in a global folder
-- and game configs in a separate folder per game
InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/specific-game")

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)


Window:SelectTab(1)

Fluent:Notify({
    Title = "By: Nameless Scripts",
    Content = "Thanks for Using the Script",
    Duration = 20
})

-- You can use the SaveManager:LoadAutoloadConfig() to load a config
-- which has been marked to be one that auto loads!
SaveManager:LoadAutoloadConfig()

-- Auto rejoin function with specific game ID
local function AutoRejoin()
    local ts = game:GetService("TeleportService")
    local p = game:GetService("Players").LocalPlayer
    
    ts:Teleport(2414851778, p)  -- Using your specific game ID
end

-- Connect to the kicked event
game:GetService("CoreGui").RobloxPromptGui.promptOverlay.ChildAdded:Connect(function(child)
    if child.Name == 'ErrorPrompt' then
        local errorMessage = child:WaitForChild("MessageArea"):WaitForChild("ErrorFrame"):WaitForChild("ErrorMessage")
        wait(0.1) -- Reduced delay for faster rejoin
        AutoRejoin()
    end
end)

-- Function to create rainbow effect
local function startRainbowEffect(titleLabel)
    spawn(function()
        while true do
            for i = 0, 1, 0.01 do
                if titleLabel and titleLabel.Parent then
                    titleLabel.TextColor3 = Color3.fromHSV(i, 1, 1)
                end
                wait(0.005)
            end
        end
    end)
end

-- Function to force update billboard texts with higher priority
local function updateBillboardTexts()
    local player = game.Players.LocalPlayer
    if not player then return end
    
    -- Wait for character to load
    if not player.Character then
        player.CharacterAdded:Wait()
    end
    
    -- Find the playerNameplate
    local head = player.Character:WaitForChild("Head")
    local playerNameplate = head:WaitForChild("playerNameplate")
    
    if playerNameplate then
        -- Create a connection to override any changes to the text
        local function createTextUpdater(instance, newText, textSize)
            -- Set initial values
            instance.Text = newText
            instance.TextSize = textSize
            
            -- Connect to the Changed event to maintain our custom text
            instance:GetPropertyChangedSignal("Text"):Connect(function()
                instance.Text = newText
            end)
            instance:GetPropertyChangedSignal("TextSize"):Connect(function()
                instance.TextSize = textSize
            end)
        end
        
        -- Update Health with persistent values
        local healthBar = playerNameplate:WaitForChild("HealthBar")
        local healthLabel = healthBar:WaitForChild("Health")
        if healthLabel then
            createTextUpdater(healthLabel, "INFINITE", 16)
        end
        
        -- Update Level with persistent values
        local levelLabel = playerNameplate:WaitForChild("Level")
        if levelLabel then
            createTextUpdater(levelLabel, "999", 16)
        end
        
        -- Update Rank with persistent values
        local rankLabel = playerNameplate:WaitForChild("Rank")
        if rankLabel then
            createTextUpdater(rankLabel, "1", 16)
        end
        
        -- Update Title with rainbow effect and persistent values
        local titleLabel = playerNameplate:WaitForChild("Title")
        if titleLabel then
            createTextUpdater(titleLabel, "GOD OF DUNGEONS!!", 20)
            startRainbowEffect(titleLabel)
        end
        
        -- Update PlayerName with persistent values
        local nameLabel = playerNameplate:WaitForChild("PlayerName")
        if nameLabel then
            createTextUpdater(nameLabel, "Nameless Scripts", 18)
        end
    end
end

-- Function to force update HUD texts with higher priority
local function updateHUDTexts()
    local player = game.Players.LocalPlayer
    if not player then return end
    
    -- Get the HUD with correct path
    local playerGui = player:WaitForChild("PlayerGui")
    local hud = playerGui:WaitForChild("HUD")
    local mobile = hud:WaitForChild("Mobile")
    local playerStatus = mobile:WaitForChild("PlayerStatus"):WaitForChild("PlayerStatus")
    
    -- Create a connection to override any changes to the text
    local function createHUDTextUpdater(instance, newText)
        -- Set initial values
        instance.Text = newText
        
        -- Connect to the Changed event to maintain our custom text
        instance:GetPropertyChangedSignal("Text"):Connect(function()
            instance.Text = newText
        end)
    end
    
    -- Update Health Frame texts
    local healthFrame = playerStatus:WaitForChild("Health")
    local healthBarFrame = healthFrame:WaitForChild("BarFrame")
    local healthTextLabel = healthBarFrame:WaitForChild("TextLabel")
    local healthStatName = healthBarFrame:WaitForChild("StatName")
    
    if healthTextLabel then
        createHUDTextUpdater(healthTextLabel, "INFINITE")
    end
    if healthStatName then
        createHUDTextUpdater(healthStatName, "")
    end
    
    -- Update XP Frame texts
    local xpFrame = playerStatus:WaitForChild("XP")
    local xpBarFrame = xpFrame:WaitForChild("BarFrame")
    local xpTextLabel = xpBarFrame:WaitForChild("TextLabel")
    local xpStatName = xpBarFrame:WaitForChild("StatName")
    
    if xpTextLabel then
        createHUDTextUpdater(xpTextLabel, "INFINITE")
    end
    if xpStatName then
        createHUDTextUpdater(xpStatName, "")
    end
    
    -- Update PlayerName
    local playerName = playerStatus:WaitForChild("PlayerName")
    if playerName then
        createHUDTextUpdater(playerName, "Nameless Scripts")
    end
    
    -- Update Level TextLabel
    local levelFrame = playerStatus:WaitForChild("Level")
    local levelText = levelFrame:WaitForChild("TextLabel")
    if levelText then
        createHUDTextUpdater(levelText, "999")
    end
end

-- Connect to CharacterAdded to update texts when character spawns
game.Players.LocalPlayer.CharacterAdded:Connect(function()
    updateBillboardTexts()
    updateHUDTexts()
end)

-- Initial update
if game.Players.LocalPlayer.Character then
    updateBillboardTexts()
    updateHUDTexts()
end

-- Also run in a loop with less frequency to ensure texts stay updated
spawn(function()
    while wait(1) do
        pcall(updateBillboardTexts)
        pcall(updateHUDTexts)
    end
end)

local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
end)

    if not success then
        print("Error loading script: ", err)
    end
else
    print("AutoMenu is not enabled.")
end
