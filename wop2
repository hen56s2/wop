if getgenv().AutoMenu then
    print("AutoMenu is enabled.")
    
    local args = {
        [1] = {
            [1] = {
                [1] = "\1"
            },
            [2] = "2"
        }
    }
    
    game:GetService("ReplicatedStorage").dataRemoteEvent:FireServer(unpack(args))
    wait(1.5)
    
    local args = {
        [1] = {
            [1] = "ui",
            [2] = "LeaderboardGui"
        }
    }
    
    game:GetService("ReplicatedStorage").Utility.AssetRequester.Remote:InvokeServer(unpack(args))
    
    local args = {
        [1] = "GetWeapons"
    }
    
    game:GetService("ReplicatedStorage").remotes.getData:InvokeServer(unpack(args))
    game:GetService("ReplicatedStorage").remotes.reloadInvy:InvokeServer()
    
    local args = {
        [1] = "Desert Temple"
    }
    
    game:GetService("ReplicatedStorage").remotes.getDungeonStats:InvokeServer(unpack(args))
    
    local args = {
        [1] = {
            [1] = {
                [1] = "\1",
                [2] = {
                    ["\3"] = "select",
                    ["characterIndex"] = 1
                }
            },
            [2] = "L"
        }
    }
    
    game:GetService("ReplicatedStorage").dataRemoteEvent:FireServer(unpack(args))   
    
    wait(0.9)
    
    local success, err = pcall(function()

local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local Window = Fluent:CreateWindow({
    Title = "Dungeon Quest | NS HUB",
    SubTitle = "Free Version",
    TabWidth = 120,
    Size = UDim2.fromOffset(530, 350),
    Acrylic = true, -- The blur may be detectable, setting this to false disables blur entirely
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl -- Used when theres no MinimizeKeybind
})

--Fluent provides Lucide Icons https://lucide.dev/icons/ for the tabs, icons are optional
local Tabs = {
    Main = Window:AddTab({ Title = "INFO", Icon = "scroll" }),
    Settings = Window:AddTab({ Title = "MACRO", Icon = "settings" })
}

local Options = Fluent.Options

do
    Fluent:Notify({
        Title = "Notification",
        Content = "This is a notification",
        SubContent = "SubContent", -- Optional
        Duration = 5 -- Set to nil to make the notification not disappear
    })

    Tabs.Main:AddParagraph({
        Title = "Script is Working!",
        Content = ""
    })
    
    Tabs.Main:AddParagraph({
        Title = "Supported Devices",
        Content = "- Mobile\n- PC\n- Emulator"
    })
    
    Tabs.Main:AddParagraph({
        Title = "Credits to : Nameless Scripts\nYoutube: Nameless Scripts\nDiscord: https://discord.gg/ZkptAdmFDg",
        Content = ""
    })


    local Tabs = {
        Main = Window:AddTab({ Title = "â•‘ AUTO FARM", Icon = "user-cog" }),
    }

    local ToggleSection = Tabs.Main:AddSection("KILL AURA", {
    })

    local Toggle = Tabs.Main:AddToggle("ToogleFastKillAura", {Title = "Fast Kill Aura [Working!]", Default = false })
    local RunService = game:GetService("RunService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    
    local dataRemoteEvent = ReplicatedStorage:WaitForChild("dataRemoteEvent")
    local fixedSentAt = tick() -- Set once outside the loop
    
    local args = {
        {
            {
                animationLength = 0,
                sentAt = fixedSentAt
            },
            "G"
        }
    }
    
    local connection
    local function checkToggle()
        if connection then
            connection:Disconnect()
            connection = nil
        end
        
        if Toggle.Value then
            connection = RunService.Heartbeat:Connect(function()
                dataRemoteEvent:FireServer(unpack(args))
            end)
        end
    end
    
    Toggle:OnChanged(checkToggle)
    checkToggle()

    local ToggleSection = Tabs.Main:AddSection("Skills", {
    })

    local VirtualInputManager = game:GetService("VirtualInputManager")
local player = game.Players.LocalPlayer

-- Attack Mode Dropdown
local selectedValue = ""

local Dropdown = Tabs.Main:AddDropdown("DropdownSelectAttack", {
    Title = "Select A Dungeon Mode",
    Values = {"Wave Defense", "Normal Dungeons"},
    Multi = false,
    Default = 1,
})

Dropdown:SetValue("Wave Defense")

Dropdown:OnChanged(function(Value)
    selectedValue = Value
end)

-- Skill Mode Dropdown
local skillMode = "No Hold"

local SkillModeDropdown = Tabs.Main:AddDropdown("DropdownSelectSkillMode", {
    Title = "Select Skill Mode",
    Values = {"No Hold", "Hold Skill"},
    Multi = false,
    Default = 1,
})

SkillModeDropdown:SetValue("No Hold")

SkillModeDropdown:OnChanged(function(Value)
    skillMode = Value
end)

-- Multi-select Dropdown for Hold Skills
local selectedSkills = {}

local HoldSkillsDropdown = Tabs.Main:AddDropdown("MultiDropdownSelectHoldSkills", {
    Title = "Select Skills to Hold",
    Values = {"Q", "E"},
    Multi = true,
    Default = {},
})

HoldSkillsDropdown:OnChanged(function(Value)
    selectedSkills = {}
    for skill, state in pairs(Value) do
        if state then
            table.insert(selectedSkills, skill)
        end
    end
end)

-- Toggle for Auto Skill
local isToggleOn = false
local ToggleAttack = Tabs.Main:AddToggle("ToogleAutoSkills", {Title = "Auto Skill Selected", Default = false })

local keySequence = {Enum.KeyCode.Q, Enum.KeyCode.E}  -- Q and E key codes
local keyPressDelay = 0.3 -- Time delay between key presses
local holdDuration = 2 -- Duration to hold the key in seconds

-- Function to simulate key press
local function simulateKeyPress(keyCode)
    local hold = skillMode == "Hold Skill" and table.find(selectedSkills, keyCode.Name)
    VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
    if hold then
        wait(holdDuration)
    else
        wait()
    end
    VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
end

local function findNearestEnemy(path)
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return nil end

    local hrp = character.HumanoidRootPart
    local nearestEnemy = nil
    local minDistance = math.huge

    for _, enemy in pairs(path:GetChildren()) do
        if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") then
            local distance = (enemy.HumanoidRootPart.Position - hrp.Position).Magnitude
            if distance < minDistance and distance <= 50 then
                minDistance = distance
                nearestEnemy = enemy
            end
        end
    end

    return nearestEnemy
end

local function findNearestDungeonEnemy(dungeonPath)
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return nil end

    local hrp = character.HumanoidRootPart
    local nearestEnemy = nil
    local minDistance = math.huge

    for _, subfolder in pairs(dungeonPath:GetChildren()) do
        if subfolder:IsA("Folder") then
            local enemyFolder = subfolder:FindFirstChild("enemyFolder")
            if enemyFolder then
                for _, enemy in pairs(enemyFolder:GetChildren()) do
                    if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") then
                        local distance = (enemy.HumanoidRootPart.Position - hrp.Position).Magnitude
                        if distance < minDistance and distance <= 50 then
                            minDistance = distance
                            nearestEnemy = enemy
                        end
                    end
                end
            end
        end
    end

    return nearestEnemy
end

local function findOdinReincarnation()
    local workspace = game:GetService("Workspace")
    local odin = workspace:FindFirstChild("Odin Reincarnation")

    if odin and odin:IsA("Model") and odin:FindFirstChild("HumanoidRootPart") then
        local character = player.Character
        if character and character:FindFirstChild("HumanoidRootPart") then
            local distance = (odin.HumanoidRootPart.Position - character.HumanoidRootPart.Position).Magnitude
            if distance <= 50 then
                return odin
            end
        end
    end

    return nil
end

local function HandleToggleAction()
    while isToggleOn do
        local nearestEnemy

        if selectedValue == "Wave Defense" then
            nearestEnemy = findNearestEnemy(game.Workspace.enemies)
        elseif selectedValue == "Normal Dungeons" then
            nearestEnemy = findNearestDungeonEnemy(game.Workspace.dungeon)
        end

        -- If no enemy found in the selected mode, search for Odin Reincarnation
        if not nearestEnemy then
            nearestEnemy = findOdinReincarnation()
        end

        if nearestEnemy then
            for _, keyCode in ipairs(keySequence) do
                if not isToggleOn then break end
                simulateKeyPress(keyCode)
                wait(keyPressDelay)
            end
        end
        
        wait(0.1)  -- Small delay to prevent excessive checking
    end
end

ToggleAttack:OnChanged(function(value)
    isToggleOn = value

    if isToggleOn then
        spawn(HandleToggleAction)
    end
end)

if ToggleAttack.Value then
    spawn(HandleToggleAction)
end

local ToggleSection = Tabs.Main:AddSection("Dungeon Set Up", {
})

-- The rest of your toggles remain unchanged
local Toggle = Tabs.Main:AddToggle("ToogleAutoStart", {Title = "Auto Start Dungeon", Default = false })
local function checkToggle()
    while Toggle.Value do
        game:GetService("ReplicatedStorage").remotes.changeStartValue:FireServer()
        wait(5)
    end
end

Toggle:OnChanged(checkToggle)
checkToggle()

local Toggle = Tabs.Main:AddToggle("ToogleAutoRetry", {Title = "Auto Retry", Default = false })
local function checkToggle()
    while Toggle.Value do
        local args = {
            [1] = {
                [1] = {
                    ["\3"] = "vote",
                    ["vote"] = true
                },
                [2] = "."
            }
        }
        
        game:GetService("ReplicatedStorage").dataRemoteEvent:FireServer(unpack(args))
        wait(2)
    end
end

Toggle:OnChanged(checkToggle)
checkToggle()



local Toggle = Tabs.Main:AddToggle("MyToggle", {Title = "Auto Inf Boss", Default = false })
local function checkToggle()
    while Toggle.Value do
        game:GetService("ReplicatedStorage").remotes.changeStartValue:FireServer()
        wait()
    end
end

Toggle:OnChanged(checkToggle)
checkToggle()

local isToggleOn = false
local detached = false
local teleporting = false

-- Initialize player references
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
local humanoid = character:WaitForChild("Humanoid")

-- Initialize TweenService
local TweenService = game:GetService("TweenService")

-- Function to detach the character
local function detachCharacter()
    if not detached then
        detached = true
        humanoidRootPart.Anchored = true
        humanoidRootPart.CanCollide = false
    end
end

-- Function to reattach the character
local function reattachCharacter()
    if detached then
        detached = false
        humanoidRootPart.Anchored = false
        humanoidRootPart.CanCollide = true
    end
end

-- Function to handle the toggle cycle
local function startToggleCycle()
    spawn(function()
        while isToggleOn do
            detachCharacter()
            wait(4)
            if not isToggleOn then break end
            reattachCharacter()
            wait(4)
        end
    end)
end

-- Enemy types and their corresponding settings
local ENEMY_TYPES = {
    ["Tether"] = {
        distance = 2,
        height = 8.5,
        priority = 0,
        tilt = {
            x = -20,
            y = 0,
            z = 0
        }
    },
    ["Adelys"] = {
        distance = 2,
        height = 25,
        priority = 0,
        tilt = {
            x = -20,
            y = 0,
            z = 0
        }
    },
    ["Hela"] = {
        distance = 2,
        height = 8.5,
        priority = 0,
        tilt = {
            x = -20,
            y = 0,
            z = 0
        }
    },
    ["Exalted Queensguard"] = {
        distance = 2,
        height = 5,
        priority = 1,
        tilt = {
            x = -45,
            y = 0,
            z = -10
        }
    },
    ["Eldritch Reaver"] = {
        distance = 5,
        height = -6,
        priority = 3,
        tilt = {
            x = -20,
            y = 0,
            z = 0
        }
    },
    ["Eldritch Prophet"] = {
        distance = 2,
        height = 10,
        priority = 2,
        tilt = {
            x = -45,
            y = 0,
            z = -10
        }
    },
    ["Corrupted Growth"] = {
        distance = 0,
        height = -40,
        priority = 4,
        specialHandling = true
    },
    ["Voidshade"] = {
        distance = 0,
        height = -40,
        priority = 4,
        specialHandling = true
    },
    ["regular"] = {
        distance = 2,
        height = 8.5,
        priority = 4,
        tilt = {
            x = -20,
            y = 0,
            z = 0
        }
    },
    ["Void Familiar"] = {
        distance = 15,
        height = 0,
        priority = 5,
        tilt = {
            x = 0,
            y = 0,
            z = 0
        }
    }
}

-- Modified function to find enemies by priority
local function findEnemy()
    local foundEnemy = nil
    local enemyType = "regular"
    local highestPriority = math.huge
    local myPosition = humanoidRootPart.Position
    local closestDistance = math.huge
    
    -- Check regular enemies
    for _, subfolder in pairs(workspace.dungeon:GetChildren()) do
        if subfolder:IsA("Folder") then
            local enemyFolder = subfolder:FindFirstChild("enemyFolder")
            if enemyFolder then
                for _, enemy in pairs(enemyFolder:GetChildren()) do
                    if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") then
                        local distance = (enemy.HumanoidRootPart.Position - myPosition).magnitude
                        local enemyConfig = ENEMY_TYPES[enemy.Name]
                        
                        if enemyConfig and enemyConfig.priority < highestPriority then
                            foundEnemy = enemy
                            enemyType = enemy.Name
                            highestPriority = enemyConfig.priority
                            closestDistance = distance
                        elseif enemyConfig and enemyConfig.priority == highestPriority and distance < closestDistance then
                            foundEnemy = enemy
                            enemyType = enemy.Name
                            closestDistance = distance
                        elseif not enemyConfig and highestPriority > ENEMY_TYPES["regular"].priority then
                            foundEnemy = enemy
                            enemyType = "regular"
                            highestPriority = ENEMY_TYPES["regular"].priority
                            closestDistance = distance
                        end
                    end
                end
            end
        end
    end
    
    return foundEnemy, enemyType
end

-- Modified floatToTarget function
local function floatToTarget(enemy, enemyType)
    if enemy and not enemy:IsA("Player") then
        local enemyConfig = ENEMY_TYPES[enemyType]
        
        -- Special handling for Corrupted Growth and Voidshade
        if enemyType == "Corrupted Growth" or enemyType == "Voidshade" then
            local offset = Vector3.new(0, -40, 0)
            local downwardRotation = CFrame.Angles(math.rad(78), 0, 0)
            humanoidRootPart.CFrame = CFrame.new(enemy.HumanoidRootPart.Position + offset) * downwardRotation
            return
        end
        
        -- Regular handling for other enemies
        local enemyPos = enemy.HumanoidRootPart.Position
        local lookVector = enemy.HumanoidRootPart.CFrame.LookVector
        
        local targetPosition = enemyPos - (lookVector * enemyConfig.distance)
        targetPosition = Vector3.new(targetPosition.X, enemyPos.Y + enemyConfig.height, targetPosition.Z)
        
        local facing = CFrame.new(targetPosition, enemyPos)
        
        local tilt = CFrame.Angles(
            math.rad(enemyConfig.tilt.x),
            math.rad(enemyConfig.tilt.y),
            math.rad(enemyConfig.tilt.z)
        )
        
        humanoidRootPart.CFrame = facing * tilt
    end
end

local function onHeartbeat()
    if isToggleOn and teleporting then
        local targetEnemy, enemyType = findEnemy()
        if targetEnemy then
            floatToTarget(targetEnemy, enemyType)
        end
    end
end

local Toggle = Tabs.Main:AddToggle("ToogleNewFarm", {
    Title = "Auto Farm Normal Enemies",
    Default = false
})

local heartbeatConnection = nil

Toggle:OnChanged(function(value)
    isToggleOn = value
    teleporting = value
    
    if isToggleOn then
        startToggleCycle()
        
        if heartbeatConnection then
            heartbeatConnection:Disconnect()
        end
        heartbeatConnection = game:GetService("RunService").Heartbeat:Connect(onHeartbeat)
    else
        reattachCharacter()
        
        if heartbeatConnection then
            heartbeatConnection:Disconnect()
        end
    end
end)

player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    humanoid = character:WaitForChild("Humanoid")
    
    if isToggleOn then
        wait(0.1)
        detachCharacter()
    end
end)

local Tabs = {
    Main = Window:AddTab({ Title = "â•‘ CREATE", Icon = "smile-plus" }),
}

local isToggleOn = false
local selectedValues = {
dungeonName = "Desert Temple",
mode = "Normal",
difficulty = "Easy",
minimumJoinLevel = 0,
maxPlayers = 40,
visibility = "Public",
tier = 1,
partyName = "123"  -- Added partyName field
}

local normalDungeonNames = {
"Desert Temple",
"Winter Outpost",
"Pirate Island",
"King's Castle",
"The UnderWorld",
"Samurai Palace",
"The Canals",
"Ghastly Harbor",
"Steampunk Sewers",
"Orbital Outpost",
"Volcanic Chambers",
"Aquatic Temple",
"Enchanted Forest",
"Northern Lands",
"Gilded Skies",
"Yokai Peak",
"[Legacy] Desert Temple",
"[Legacy] Winter Outpost",
"Abyssal Void"
}

local insaneNightmareDungeons = {
"Pirate Island",
"King's Castle",
"The UnderWorld",
"Samurai Palace",
"The Canals",
"Ghastly Harbor",
"Steampunk Sewers",
"Orbital Outpost",
"Volcanic Chambers",
"Aquatic Temple",
"Enchanted Forest",
"Northern Lands",
"Gilded Skies",
"Yokai Peak",
"Abyssal Void"
}

local noWaveDefenseDungeons = {
"Desert Temple",
"[Legacy] Desert Temple",
"[Legacy] Winter Outpost",
"Winter Outpost",
"Ghastly Harbor",
"Steampunk Sewers",
"Orbital Outpost",
"Volcanic Chambers",
"Aquatic Temple",
"Enchanted Forest",
"Northern Lands",
"Gilded Skies",
"Yokai Peak",
"Abyssal Void"
}

local function CreateDropdown(name, title, values, default)
local Dropdown = Tabs.Main:AddDropdown(name, {
    Title = title,
    Values = values,
    Multi = false,
    Default = default,
})

Dropdown:SetValue(default)

Dropdown:OnChanged(function(Value)
    selectedValues[name] = Value
end)

return Dropdown
end

local dungeonDropdown = CreateDropdown("ToogleAutoDungeonName", "Select Dungeon", normalDungeonNames, "Desert Temple")
local modeDropdown = CreateDropdown("ToogleAutoMode", "Select Mode", {"Normal", "Hardcore"}, "Normal")
local difficultyDropdown = CreateDropdown("ToogleAutoSelect", "Select Difficulty", {"Easy", "Medium", "Hard"}, "Easy")
CreateDropdown("ToogleAutoMinimumLevel", "Minimum Join Level", {0, 10, 20, 30, 40, 50}, 0)
CreateDropdown("ToogleAutoMaxPlayer", "Max Players", {1, 2, 4, 8, 16, 32, 40}, 40)
CreateDropdown("visibility", "Select Visibility", {"Public", "Private"}, "Public")

-- Add party name input
local partyNameInput = Tabs.Main:AddInput("PartyNameInput", {
Title = "Party Name",
Default = "123",
Placeholder = "Enter party name",
Numeric = false,
Finished = false,
Callback = function(Value)
    selectedValues.partyName = Value
end
})

dungeonDropdown:OnChanged(function(Value)
selectedValues["dungeonName"] = Value
local difficultyOptions
if table.find(insaneNightmareDungeons, Value) then
    difficultyOptions = {"Insane", "Nightmare"}
elseif Value:find("^%[Legacy%]") then
    difficultyOptions = {"Easy", "Medium", "Hard", "Insane", "Nightmare"}
elseif Value == "Desert Temple" or Value == "Winter Outpost" then
    difficultyOptions = {"Easy", "Medium", "Hard"}
else
    difficultyOptions = {"Easy", "Medium", "Hard", "Insane", "Nightmare"}
end
difficultyDropdown:SetValues(difficultyOptions)
difficultyDropdown:SetValue(difficultyOptions[1])
selectedValues["difficulty"] = difficultyOptions[1]

local modeOptions = {"Normal", "Hardcore"}
if not table.find(noWaveDefenseDungeons, Value) then
    table.insert(modeOptions, "Wave Defense")
end
modeDropdown:SetValues(modeOptions)
if not table.find(modeOptions, selectedValues["mode"]) then
    modeDropdown:SetValue("Normal")
    selectedValues["mode"] = "Normal"
end
end)

local Toggle = Tabs.Main:AddToggle("ToogleAutoStartDungeon", {Title = "Auto Make + Start Dungeon Configured", Default = false })

local function CreateParty()
local args = {
    [1] = {
        [1] = {
            [1] = "\1",
            [2] = {
                ["\3"] = "CreateParty",
                ["partyData"] = {
                    ["dungeonName"] = selectedValues.dungeonName,
                    ["mode"] = selectedValues.mode,
                    ["difficulty"] = selectedValues.difficulty,
                    ["minimumJoinLevel"] = selectedValues.minimumJoinLevel,
                    ["maxPlayers"] = selectedValues.maxPlayers,
                    ["visibility"] = selectedValues.visibility,
                    ["tier"] = selectedValues.tier,
                    ["partyName"] = selectedValues.partyName  -- Added partyName field
                }
            }
        },
        [2] = "5"
    }
}

game:GetService("ReplicatedStorage"):WaitForChild("dataRemoteEvent"):FireServer(unpack(args))
end

local function StartParty()
local args = {
    [1] = {
        [1] = {
            [1] = "\1",
            [2] = {
                ["\3"] = "StartParty"
            }
        },
        [2] = "5"
    }
}

game:GetService("ReplicatedStorage").dataRemoteEvent:FireServer(unpack(args))
end

local function HandleToggleAction()
while isToggleOn do
    CreateParty()
    wait(1)  -- Wait for 1 second to ensure party is created
    StartParty()
    wait(5)  -- Wait for 5 seconds before creating a new party
end
end

Toggle:OnChanged(function(value)
isToggleOn = value

if isToggleOn then
    spawn(HandleToggleAction)
end
end)

if Toggle.Value then
spawn(HandleToggleAction)
end

            local Toggle = Tabs.Main:AddToggle("ToogleAntiAFK", {Title = "Anti AFK", Default = false })

            local function AntiAFK()
                local Players = game:GetService("Players")
                local VirtualUser = game:GetService("VirtualUser")
            
                local function ResetStatus()
                    print("Status: 123")
                end
            
                Players.LocalPlayer.Idled:Connect(function()
                    VirtualUser:CaptureController()
                    VirtualUser:ClickButton2(Vector2.new())
                    print("Best Scripter Nameless Scripts")
                    wait(2)
                    ResetStatus()
                end)
            end
            
            local function checkToggle()
                if Toggle.Value then
                    AntiAFK()
                end
            end
            
            Toggle:OnChanged(checkToggle)
            checkToggle()        



    local Input = Tabs.Main:AddInput("Input", {
        Title = "Input",
        Default = "Default",
        Placeholder = "Placeholder",
        Numeric = false, -- Only allows numbers
        Finished = false, -- Only calls callback when you press enter
        Callback = function(Value)
            print("Input changed:", Value)
        end
    })

    Input:OnChanged(function()
        print("Input updated:", Input.Value)
    end)
end


-- Addons:
-- SaveManager (Allows you to have a configuration system)
-- InterfaceManager (Allows you to have a interface managment system)

-- Hand the library over to our managers
SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)

-- Ignore keys that are used by ThemeManager.
-- (we dont want configs to save themes, do we?)
SaveManager:IgnoreThemeSettings()

-- You can add indexes of elements the save manager should ignore
SaveManager:SetIgnoreIndexes({})

-- use case for doing it this way:
-- a script hub could have themes in a global folder
-- and game configs in a separate folder per game
InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/specific-game")

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)


Window:SelectTab(1)

Fluent:Notify({
    Title = "By: Nameless Scripts",
    Content = "Thanks for Using the Script",
    Duration = 20
})

-- You can use the SaveManager:LoadAutoloadConfig() to load a config
-- which has been marked to be one that auto loads!
SaveManager:LoadAutoloadConfig()

-- Function to create rainbow effect
local function startRainbowEffect(titleLabel)
    spawn(function()
        while true do
            for i = 0, 1, 0.01 do
                if titleLabel and titleLabel.Parent then
                    titleLabel.TextColor3 = Color3.fromHSV(i, 1, 1)
                end
                wait(0.005)
            end
        end
    end)
end

-- Function to force update billboard texts with higher priority
local function updateBillboardTexts()
    local player = game.Players.LocalPlayer
    if not player then return end
    
    -- Wait for character to load
    if not player.Character then
        player.CharacterAdded:Wait()
    end
    
    -- Find the playerNameplate
    local head = player.Character:WaitForChild("Head")
    local playerNameplate = head:WaitForChild("playerNameplate")
    
    if playerNameplate then
        -- Create a connection to override any changes to the text
        local function createTextUpdater(instance, newText, textSize)
            -- Set initial values
            instance.Text = newText
            instance.TextSize = textSize
            
            -- Connect to the Changed event to maintain our custom text
            instance:GetPropertyChangedSignal("Text"):Connect(function()
                instance.Text = newText
            end)
            instance:GetPropertyChangedSignal("TextSize"):Connect(function()
                instance.TextSize = textSize
            end)
        end
        
        -- Update Health with persistent values
        local healthBar = playerNameplate:WaitForChild("HealthBar")
        local healthLabel = healthBar:WaitForChild("Health")
        if healthLabel then
            createTextUpdater(healthLabel, "INFINITE", 16)
        end
        
        -- Update Level with persistent values
        local levelLabel = playerNameplate:WaitForChild("Level")
        if levelLabel then
            createTextUpdater(levelLabel, "999", 16)
        end
        
        -- Update Rank with persistent values
        local rankLabel = playerNameplate:WaitForChild("Rank")
        if rankLabel then
            createTextUpdater(rankLabel, "1", 16)
        end
        
        -- Update Title with rainbow effect and persistent values
        local titleLabel = playerNameplate:WaitForChild("Title")
        if titleLabel then
            createTextUpdater(titleLabel, "GOD OF DUNGEONS!!", 20)
            startRainbowEffect(titleLabel)
        end
        
        -- Update PlayerName with persistent values
        local nameLabel = playerNameplate:WaitForChild("PlayerName")
        if nameLabel then
            createTextUpdater(nameLabel, "Nameless Scripts", 18)
        end
    end
end

-- Function to force update HUD texts with higher priority
local function updateHUDTexts()
    local player = game.Players.LocalPlayer
    if not player then return end
    
    -- Get the HUD with correct path
    local playerGui = player:WaitForChild("PlayerGui")
    local hud = playerGui:WaitForChild("HUD")
    local mobile = hud:WaitForChild("Mobile")
    local playerStatus = mobile:WaitForChild("PlayerStatus"):WaitForChild("PlayerStatus")
    
    -- Create a connection to override any changes to the text
    local function createHUDTextUpdater(instance, newText)
        -- Set initial values
        instance.Text = newText
        
        -- Connect to the Changed event to maintain our custom text
        instance:GetPropertyChangedSignal("Text"):Connect(function()
            instance.Text = newText
        end)
    end
    
    -- Update Health Frame texts
    local healthFrame = playerStatus:WaitForChild("Health")
    local healthBarFrame = healthFrame:WaitForChild("BarFrame")
    local healthTextLabel = healthBarFrame:WaitForChild("TextLabel")
    local healthStatName = healthBarFrame:WaitForChild("StatName")
    
    if healthTextLabel then
        createHUDTextUpdater(healthTextLabel, "INFINITE")
    end
    if healthStatName then
        createHUDTextUpdater(healthStatName, "")
    end
    
    -- Update XP Frame texts
    local xpFrame = playerStatus:WaitForChild("XP")
    local xpBarFrame = xpFrame:WaitForChild("BarFrame")
    local xpTextLabel = xpBarFrame:WaitForChild("TextLabel")
    local xpStatName = xpBarFrame:WaitForChild("StatName")
    
    if xpTextLabel then
        createHUDTextUpdater(xpTextLabel, "INFINITE")
    end
    if xpStatName then
        createHUDTextUpdater(xpStatName, "")
    end
    
    -- Update PlayerName
    local playerName = playerStatus:WaitForChild("PlayerName")
    if playerName then
        createHUDTextUpdater(playerName, "Nameless Scripts")
    end
    
    -- Update Level TextLabel
    local levelFrame = playerStatus:WaitForChild("Level")
    local levelText = levelFrame:WaitForChild("TextLabel")
    if levelText then
        createHUDTextUpdater(levelText, "999")
    end
end

-- Connect to CharacterAdded to update texts when character spawns
game.Players.LocalPlayer.CharacterAdded:Connect(function()
    updateBillboardTexts()
    updateHUDTexts()
end)

-- Initial update
if game.Players.LocalPlayer.Character then
    updateBillboardTexts()
    updateHUDTexts()
end

-- Also run in a loop with less frequency to ensure texts stay updated
spawn(function()
    while wait(1) do
        pcall(updateBillboardTexts)
        pcall(updateHUDTexts)
    end
end)

local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")

-- Auto rejoin function with specific game ID
local function AutoRejoin()
    local ts = game:GetService("TeleportService")
    local p = game:GetService("Players").LocalPlayer
    
    ts:Teleport(2414851778, p)  -- Using your specific game ID
end

-- Connect to the kicked event
game:GetService("CoreGui").RobloxPromptGui.promptOverlay.ChildAdded:Connect(function(child)
    if child.Name == 'ErrorPrompt' then
        local errorMessage = child:WaitForChild("MessageArea"):WaitForChild("ErrorFrame"):WaitForChild("ErrorMessage")
        wait(0.1) -- Reduced delay for faster rejoin
        AutoRejoin()
    end
end)
end)

    if not success then
        print("Error loading script: ", err)
    end
else
    print("AutoMenu is not enabled.")
end

